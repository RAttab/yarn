Module:
  declare_type %yarn.t1  ; struct

fct_header:
  %yarn.s1 = alloca %yarn.t1


%loopheader:
  %yarn.p1 = getelementptr %yarn.s1 0 0
  %yarn.p2 = getelementptr %yarn.s1 0 1
  store %1 %yarn.p1                            ; 1 per phi node in the header + read-only v
  store %2 %yarn.p2			      ; Same as phi node value.
  %yarn.r1 = call yarn_exec_simple (%yarn.s1, %yarn.f1)
  %yarn.v1 = load yarn.p1
  %yarn.v2 = load yarn.p2
  %yarn.c1 = icmp %yarn.r1 == 0
  br %yarn.c1 %loopend, %loopbegin

%loopbegin:
  ...
  ; replace entry phi-node %1, %2 by %yarn.v1-2
  ...

%loopend:
  %yarn.n1 = phi %loopheader -> %yarn.v1 else -> phi exit value %11
  %yarn.n2 = phi %loopheader -> %yarn.v2 else -> phi exit value %12
 ; replace %11 by %yarn.n1
 ; replace %12 by %yarn.n2


%yarn.f1 (pid, task)
  %yarn.s1 = bitcast task %yarn.t1
  %yarn.p1 = getelementptr %yarn.s1 0 0
  %yarn.p2 = getelementptr %yarn.s1 0 1
  %yarn.v1 = load %yarn.p1
  %yarn.v2 = load %yarn.p2
  
%loopbegin:
  ; paste loop here.
  ; replace %1 by %yarn.v1
  ; replace %2 by %yarn.v2
  ; remove phi nodes.
  ; replace back-edge by returns with continue const.
  ; replace forward-edges by %loopend

%loopend:
  ret break.


